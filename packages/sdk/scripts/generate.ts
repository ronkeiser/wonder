#!/usr/bin/env tsx
/**
 * Generate TypeScript types and client from OpenAPI spec.
 *
 * Phase 1: Generate types with custom transform hooks
 * Phase 2: Parse paths and generate client code
 * Phase 3: Write both files to src/generated/
 */

import { mkdir, writeFile } from 'node:fs/promises';
import openapiTS from 'openapi-typescript';
import ts from 'typescript';
import { formatClientCode, generateRootClient } from './generate-client.js';
import { buildRouteTree, type HttpMethod, type PathDefinition } from './parse-paths.js';

const API_URL = process.env.API_URL || 'https://api.wflow.app';
const API_KEY = process.env.API_KEY;
const DOC_URL = `${API_URL}/doc`;
const HTTP_METHODS = ['get', 'post', 'put', 'patch', 'delete'] as const;
const SCHEMA_OUTPUT_DIR = 'src/generated';

const fetchOptions: RequestInit = API_KEY ? { headers: { 'X-API-Key': API_KEY } } : {};
const AUTO_GENERATED_HEADER = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`;

/**
 * Check if a path should use JSONSchema reference
 */
function shouldUseJSONSchema(path: string): boolean {
  const workflowSchemas = ['input_schema', 'output_schema', 'context_schema'];
  return (
    (path.includes('WorkflowDef') && workflowSchemas.some((schema) => path.endsWith(schema))) ||
    (path.includes('PromptSpec') && path.endsWith('produces'))
  );
}

/**
 * Convert OpenAPI paths object to PathDefinition array
 */
export function convertOpenApiPaths(paths: Record<string, Record<string, any>>): PathDefinition[] {
  const isHttpMethod = (method: string): method is HttpMethod =>
    HTTP_METHODS.includes(method as HttpMethod);

  return Object.entries(paths).flatMap(([path, methods]) =>
    Object.entries(methods)
      .filter(([method]) => isHttpMethod(method))
      .map(([method, operation]) => ({
        path,
        method: method as HttpMethod,
        operationId: operation?.operationId,
        responses: operation?.responses,
      })),
  );
}

async function generate() {
  if (!API_KEY) {
    console.warn('Warning: API_KEY not set. Authentication may fail.');
  }

  console.log(`Fetching OpenAPI spec from ${DOC_URL}...`);

  const response = await fetch(DOC_URL, fetchOptions);
  const spec = (await response.json()) as { paths: Record<string, Record<string, any>> };

  const { factory } = ts;
  const ast = await openapiTS(spec, {
    transform(schemaObject, options) {
      return shouldUseJSONSchema(options.path ?? '')
        ? factory.createTypeReferenceNode('JSONSchema')
        : undefined;
    },
  });

  const importStatement = factory.createImportDeclaration(
    undefined,
    factory.createImportClause(
      true,
      undefined,
      factory.createNamedImports([
        factory.createImportSpecifier(false, undefined, factory.createIdentifier('JSONSchema')),
      ]),
    ),
    factory.createStringLiteral('@wonder/schemas'),
    undefined,
  );

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const sourceFile = ts.createSourceFile(
    'schema.d.ts',
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  );
  const printNode = (node: ts.Node) => printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);

  const schemaOutput =
    AUTO_GENERATED_HEADER + printNode(importStatement) + '\n' + ast.map(printNode).join('\n\n');

  console.log('Parsing API routes...');
  const pathDefs = convertOpenApiPaths(spec.paths);
  const routeTree = buildRouteTree(pathDefs);

  console.log('Generating client code...');
  const clientStructure = generateRootClient(routeTree);
  const clientOutput = formatClientCode(clientStructure);

  await mkdir(SCHEMA_OUTPUT_DIR, { recursive: true });

  const files = [
    { path: `${SCHEMA_OUTPUT_DIR}/schema.d.ts`, content: schemaOutput, label: 'types' },
    { path: `${SCHEMA_OUTPUT_DIR}/client.ts`, content: clientOutput, label: 'client' },
  ];

  await Promise.all(
    files.map(async ({ path, content, label }) => {
      await writeFile(path, content, 'utf-8');
      console.log(`âœ“ Generated ${label} written to ${path}`);
    }),
  );
}

generate().catch((err) => {
  console.error('Generation failed:', err);
  process.exit(1);
});
