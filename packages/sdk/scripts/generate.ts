#!/usr/bin/env tsx
/**
 * Generate TypeScript types and client from OpenAPI spec.
 *
 * Phase 1: Generate types with custom transform hooks
 * Phase 2: Parse paths and generate client code
 * Phase 3: Write both files to src/generated/
 */

import { mkdir, writeFile } from 'node:fs/promises';
import openapiTS from 'openapi-typescript';
import ts from 'typescript';
import { formatClientCode, generateRootClient } from './generate-client.js';
import { buildRouteTree, type HttpMethod, type PathDefinition } from './parse-paths.js';

const API_URL = process.env.API_URL || 'https://wonder-http.ron-keiser.workers.dev';
const HTTP_METHODS = ['get', 'post', 'put', 'patch', 'delete'] as const;
const SCHEMA_OUTPUT_DIR = 'src/generated';

/**
 * Check if a path should use SchemaType reference
 */
function shouldUseSchemaType(path: string): boolean {
  const workflowSchemas = ['input_schema', 'output_schema', 'context_schema'];
  const isWorkflowSchema =
    path.includes('WorkflowDef') && workflowSchemas.some((schema) => path.endsWith(schema));
  const isPromptProduces = path.includes('PromptSpec') && path.endsWith('produces');

  return isWorkflowSchema || isPromptProduces;
}

/**
 * Convert OpenAPI paths object to PathDefinition array
 */
export function convertOpenApiPaths(paths: Record<string, Record<string, any>>): PathDefinition[] {
  return Object.entries(paths).flatMap(([path, methods]) =>
    Object.entries(methods)
      .filter(([method]) => HTTP_METHODS.includes(method as any))
      .map(([method, operation]) => ({
        path,
        method: method as HttpMethod,
        operationId: operation?.operationId,
        responses: operation?.responses,
      })),
  );
}

async function generate() {
  console.log(`Fetching OpenAPI spec from ${API_URL}/doc...`);

  // Fetch OpenAPI spec as JSON for path parsing
  const response = await fetch(`${API_URL}/doc`);
  const spec = (await response.json()) as { paths: Record<string, Record<string, any>> };

  // Generate TypeScript types
  const ast = await openapiTS(`${API_URL}/doc`, {
    transform(schemaObject, options) {
      return shouldUseSchemaType(options.path || '')
        ? ts.factory.createTypeReferenceNode('SchemaType')
        : undefined;
    },
  });

  // Add import statement for SchemaType
  const importStatement = ts.factory.createImportDeclaration(
    undefined,
    ts.factory.createImportClause(
      true,
      undefined,
      ts.factory.createNamedImports([
        ts.factory.createImportSpecifier(
          false,
          undefined,
          ts.factory.createIdentifier('SchemaType'),
        ),
      ]),
    ),
    ts.factory.createStringLiteral('@wonder/context'),
    undefined,
  );

  // Combine import + generated AST
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const sourceFile = ts.createSourceFile(
    'schema.d.ts',
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  );

  const printNode = (node: ts.Node) => printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);

  const header = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`;

  const schemaOutput = [
    header,
    printNode(importStatement),
    '\n',
    ast.map(printNode).join('\n\n'),
  ].join('');

  console.log('Parsing API routes...');
  const pathDefs = convertOpenApiPaths(spec.paths);
  const routeTree = buildRouteTree(pathDefs);

  console.log('Generating client code...');
  const clientStructure = generateRootClient(routeTree);
  const clientOutput = formatClientCode(clientStructure);

  // Write files
  await mkdir(SCHEMA_OUTPUT_DIR, { recursive: true });

  const files = [
    { path: `${SCHEMA_OUTPUT_DIR}/schema.d.ts`, content: schemaOutput, label: 'types' },
    { path: `${SCHEMA_OUTPUT_DIR}/client.ts`, content: clientOutput, label: 'client' },
  ];

  for (const { path, content, label } of files) {
    await writeFile(path, content, 'utf-8');
    console.log(`âœ“ Generated ${label} written to ${path}`);
  }
}

generate().catch((err) => {
  console.error('Generation failed:', err);
  process.exit(1);
});
