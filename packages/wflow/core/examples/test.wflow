# Example workflow for testing the LSP
imports:
  start_task: "./test.task"
  process_task: "./tasks/process.task"
  missing_task: "./not-found.task"

workflow: test-workflow
version: 1
description: A simple test workflow
unknown_top_level: oops           # ⚠️ Should warn: unknown property in workflow

input_schema:
  type: object
  bad_schema_prop: test             # ⚠️ Should warn: unknown JSON Schema property
  properties:
    name: { type: string }
    count: { type: integer }
  required: [name, count]

context_schema:
  type: object
  properties:
    greeting: { type: string }
    processed_count: { type: integer }
    orphan_data: { type: string }        # Valid schema, but never written to

output_schema:
  type: object
  properties:
    result: { type: string }
  required: [result]

nodes:
  start:
    name: Start Node
    task_id: start_task
    task_version: 1
    bad_node_prop: test             # ⚠️ Should warn: unknown property in node
    input_mapping:
      name: "$.input.name"
      count: "$.input.count"
    output_mapping:
      "state.greeting": "$.greeting"

  process:
    name: Process Node
    task_id: process_task
    task_version: 1
    input_mapping:
      greeting: "$.state.greeting"
      bad_read: "$.state.nonexistent"    # ❌ Should error: path doesn't exist
    output_mapping:
      "state.processed_count": "$.count"
      "state.bad_write": "$.foo"         # ❌ Should error: path doesn't exist

  finish:
    name: Finish Node
    task_id: start_task
    task_version: 1
    input_mapping:
      greeting: "$.state.greeting"
      count: "$.state.processed_count"
      orphan: "$.state.orphan_data"      # ❌ Should error: never written by any predecessor
    output_mapping:
      "output.result": "$.final_message"

  # This node uses an unimported task - should error
  orphan_node:
    name: Orphan Node
    task_id: not_imported_task
    task_version: 1
    input_mapping:
      greeting: "$.state.greeting"
    output_mapping:
      "state.orphan_data": "$.result"

transitions:
  start_to_process:
    from_node_ref: start
    to_node_ref: process
    priority: 0

  process_to_finish:
    from_node_ref: process
    to_node_ref: finish
    priority: 0

  # This creates a cycle: finish → start → process → finish
  finish_to_start:
    from_node_ref: finish
    to_node_ref: start
    priority: 0

  # These should show red squigglies - undefined node refs
  bad_transition_1:
    from_node_ref: process
    to_node_ref: oops
    priority: 0

  bad_transition_2:
    from_node_ref: invalid
    to_node_ref: finish
    priority: 0

  # Test sibling_group validation
  fan_in_test:
    from_node_ref: process
    to_node_ref: finish
    priority: 1
    synchronization:
      strategy: all
      sibling_group: nonexistent_transition  # ❌ Should error: transition doesn't exist
      merge:
        source: "_branch.output"
        target: "state.results"
        strategy: append

  # Test foreach.collection validation
  foreach_test:
    from_node_ref: start
    to_node_ref: process
    priority: 1
    foreach:
      collection: bad_path               # ❌ Should error: must be state.* path
      item_var: item

initial_node_ref: start
timeout_ms: 60000
on_timeout: fail
