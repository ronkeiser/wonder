import {
  action,
  node,
  promptSpec,
  schema as s,
  step,
  task,
  transition,
  workflow,
} from '@wonder/sdk';
import { describe, expect, it } from 'vitest';
import { runTestWorkflow } from '~/kit';

/**
 * Two-Node Linear Workflow Test
 *
 * Tests the coordinator's ability to:
 * 1. Execute an initial node
 * 2. Evaluate a transition after node completion
 * 3. Route to and execute a second node
 * 4. Apply output mappings at each stage
 * 5. Complete the workflow with final output
 *
 * Workflow structure:
 *   [generate_node] â†’ [echo_node] â†’ (complete)
 *
 * CRITICAL: This test proves data flows between nodes by having:
 * - Node 1: Generate a random 4-digit code (unpredictable)
 * - Node 2: Echo back the code it received
 *
 * If the code in final output matches what node 1 produced,
 * we've proven the data actually flowed through state.
 *
 * Validates trace events for:
 * - Token creation (2 tokens total)
 * - Transition evaluation
 * - Output mapping at each node
 * - Workflow completion
 */
describe('Coordinator - Two Node Linear Workflow', () => {
  it('executes two nodes in sequence with data flowing through state', async () => {
    // Input is minimal - the interesting data is GENERATED by node 1
    const inputData = { seed: Date.now() };

    // =========================================================================
    // Schemas
    // =========================================================================
    const inputSchema = s.object({ seed: s.number() }, { required: ['seed'] });

    // First node output: generates a random code
    const codeSchema = s.object({ code: s.string() }, { required: ['code'] });

    // Second node output: echoes the code it received
    const echoSchema = s.object({ echoed_code: s.string() }, { required: ['echoed_code'] });

    // Workflow output: the echoed code
    const workflowOutputSchema = s.object({ final_code: s.string() }, { required: ['final_code'] });

    // =========================================================================
    // Node 1: Generate - Creates a random 4-digit code
    // =========================================================================
    const generatePrompt = promptSpec({
      name: 'Generate Code Prompt',
      description: 'Generates a random 4-digit code',
      template:
        'Generate a random 4-digit numeric code. Use seed {{seed}} as inspiration but make it random. Return ONLY a JSON object with a "code" field containing exactly 4 digits as a string.',
      template_language: 'handlebars',
      requires: { seed: s.number() },
      produces: codeSchema,
    });

    const generateAction = action({
      name: 'Generate Code Action',
      description: 'Generates random code',
      kind: 'llm_call',
      implementation: { prompt_spec: generatePrompt },
    });

    const generateStep = step({
      ref: 'generate_step',
      ordinal: 0,
      action: generateAction,
      action_version: 1,
      input_mapping: { seed: '$.input.seed' },
      output_mapping: { 'output.code': '$.response.code' },
    });

    const generateTask = task({
      name: 'Generate Code Task',
      description: 'Task that generates a random code',
      input_schema: s.object({ seed: s.number() }, { required: ['seed'] }),
      output_schema: codeSchema,
      steps: [generateStep],
    });

    const generateNode = node({
      ref: 'generate_node',
      name: 'Generate Code',
      task: generateTask,
      task_version: 1,
      input_mapping: { seed: '$.input.seed' },
      output_mapping: { 'state.generated_code': '$.code' },
    });

    // =========================================================================
    // Node 2: Echo - Receives code from state, echoes it back
    // =========================================================================
    const echoPrompt = promptSpec({
      name: 'Echo Code Prompt',
      description: 'Echoes back the code it received',
      template:
        'You received this code: {{code}}. Return ONLY a JSON object with an "echoed_code" field containing the EXACT same code you received. Do not modify it.',
      template_language: 'handlebars',
      requires: { code: s.string() },
      produces: echoSchema,
    });

    const echoAction = action({
      name: 'Echo Code Action',
      description: 'Echoes received code',
      kind: 'llm_call',
      implementation: { prompt_spec: echoPrompt },
    });

    const echoStep = step({
      ref: 'echo_step',
      ordinal: 0,
      action: echoAction,
      action_version: 1,
      input_mapping: { code: '$.input.code' },
      output_mapping: { 'output.echoed_code': '$.response.echoed_code' },
    });

    const echoTask = task({
      name: 'Echo Code Task',
      description: 'Task that echoes code',
      input_schema: s.object({ code: s.string() }, { required: ['code'] }),
      output_schema: echoSchema,
      steps: [echoStep],
    });

    const echoNode = node({
      ref: 'echo_node',
      name: 'Echo Code',
      task: echoTask,
      task_version: 1,
      // THIS IS THE KEY: reads from state.generated_code written by node 1
      input_mapping: { code: '$.state.generated_code' },
      output_mapping: { 'output.final_code': '$.echoed_code' },
    });

    // =========================================================================
    // Transition: generate_node â†’ echo_node
    // =========================================================================
    const generateToEcho = transition({
      ref: 'generate_to_echo',
      from_node_ref: 'generate_node',
      to_node_ref: 'echo_node',
      priority: 1,
    });

    // =========================================================================
    // Workflow
    // =========================================================================
    const { result, cleanup } = await runTestWorkflow(
      workflow({
        name: `Two Node Linear Workflow ${Date.now()}`,
        description: 'Tests two-node linear execution proving data flows through state',
        input_schema: inputSchema,
        context_schema: s.object({
          generated_code: s.string(),
        }),
        output_schema: workflowOutputSchema,
        output_mapping: {
          final_code: '$.output.final_code',
        },
        initial_node_ref: 'generate_node',
        nodes: [generateNode, echoNode],
        transitions: [generateToEcho],
      }),
      inputData,
      { logEvents: false },
    );

    // =========================================================================
    // Assertions
    // =========================================================================
    console.log('\nðŸ” Two-Node Linear Workflow Validation\n');

    // 1. Workflow completed successfully
    expect(result.status).toBe('completed');
    console.log('  âœ“ Workflow completed successfully');

    const { trace } = result;

    // 2. Context initialization
    const contextInit = trace.context.initialize();
    expect(contextInit).toBeDefined();
    console.log(`  âœ“ Context initialized (${contextInit!.payload.table_count} tables)`);

    // 3. Input validation
    const inputValidation = trace.context.validateAt('input');
    expect(inputValidation).toBeDefined();
    expect(inputValidation!.payload.valid).toBe(true);
    console.log('  âœ“ Input validated');

    // 4. Two tokens created (one per node)
    const tokenCreations = trace.tokens.creations();
    expect(tokenCreations.length).toBe(2);
    console.log(`  âœ“ ${tokenCreations.length} tokens created`);

    // First token for generate_node
    const firstToken = tokenCreations[0];
    expect(firstToken.payload.node_id).toBeDefined();
    console.log(`    - Token 1: node=${firstToken.payload.node_id}`);

    // Second token for echo_node
    const secondToken = tokenCreations[1];
    expect(secondToken.payload.node_id).toBeDefined();
    console.log(`    - Token 2: node=${secondToken.payload.node_id}`);

    // 5. Transition was evaluated
    const routingStart = trace.routing.starts();
    expect(routingStart.length).toBeGreaterThanOrEqual(1);
    console.log(`  âœ“ ${routingStart.length} routing decisions made`);

    // 6. Transition matched (generate â†’ echo)
    const transitionMatches = trace.routing.matches();
    expect(transitionMatches.length).toBeGreaterThanOrEqual(1);
    console.log(`  âœ“ ${transitionMatches.length} transition(s) matched`);

    // 7. CRITICAL: Extract the code that node 1 generated and wrote to state
    const stateWrites = trace.context.writesTo('state');
    const codeWrite = stateWrites.find((w) => {
      const value = w.payload.value as Record<string, unknown>;
      return value && 'generated_code' in value;
    });
    expect(codeWrite).toBeDefined();
    const generatedCode = (codeWrite!.payload.value as Record<string, string>).generated_code;
    console.log(`  âœ“ Node 1 generated code: "${generatedCode}"`);

    // 8. Output mapping applied for second node (writes to output)
    const outputWrites = trace.context.writesTo('output');
    expect(outputWrites.length).toBeGreaterThan(0);
    console.log('  âœ“ Second node wrote to output');

    // 9. Workflow completion extracted final output
    const completionStart = trace.completion.start();
    expect(completionStart).toBeDefined();
    console.log('  âœ“ Completion started');

    const completionComplete = trace.completion.complete();
    expect(completionComplete).toBeDefined();
    const finalOutput = completionComplete!.payload.final_output as { final_code: string };
    expect(finalOutput).toBeDefined();
    console.log(`  âœ“ Final output: ${JSON.stringify(finalOutput)}`);

    // 10. THE KEY ASSERTION: The echoed code must match the generated code
    // This proves data actually flowed from node 1 â†’ state â†’ node 2
    expect(finalOutput.final_code).toBe(generatedCode);
    console.log(
      `  âœ“ PROVEN: Echoed code "${finalOutput.final_code}" matches generated code "${generatedCode}"`,
    );

    // 11. Verify token status transitions
    const firstTokenId = firstToken.payload.token_id;
    const secondTokenId = secondToken.payload.token_id;

    const firstTokenStatuses = trace.tokens.statusTransitions(firstTokenId);
    const secondTokenStatuses = trace.tokens.statusTransitions(secondTokenId);

    console.log(`  âœ“ Token 1 status transitions: ${firstTokenStatuses.join(' â†’ ')}`);
    console.log(`  âœ“ Token 2 status transitions: ${secondTokenStatuses.join(' â†’ ')}`);

    // Both tokens should reach 'completed'
    expect(firstTokenStatuses).toContain('completed');
    expect(secondTokenStatuses).toContain('completed');

    console.log('\nâœ… Two-node linear workflow validation complete - DATA FLOW PROVEN\n');

    await cleanup();
  });
});
